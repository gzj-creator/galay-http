# S2-检查脚本文档

## 脚本概述

`S2-Check.sh` 是一个通用的验证脚本，用于检查项目的构建状态、测试文件、压测文件、文档完整性和命名规范。该脚本帮助开发者确保项目结构符合规范，所有组件完整可用。

## 功能说明

### 主要功能

1. **构建状态检查**：验证构建目录结构是否完整
2. **测试文件检查**：检查测试文件数量和命名规范
3. **压测文件检查**：检查压测文件数量和命名规范
4. **文档完整性检查**：验证文档目录和 README 是否存在
5. **命名规范检查**：全面检查所有文件的命名是否符合项目规范

### 核心特性

- **模块化检查**：支持单独执行某一项检查或全部检查
- **彩色输出**：使用颜色区分检查结果（成功/失败/警告）
- **详细报告**：提供文件数量统计和不规范文件列表
- **退出码支持**：检查失败时返回非零退出码，便于 CI/CD 集成

## 使用方法

### 基本语法

```bash
./scripts/S2-Check.sh [选项]
```

### 参数说明

| 选项 | 说明 | 检查内容 |
|------|------|----------|
| `--build` | 检查构建状态 | 验证 build 目录及子目录存在 |
| `--tests` | 检查测试文件 | 验证测试文件命名规范 |
| `--benchmarks` | 检查压测文件 | 验证压测文件命名规范 |
| `--docs` | 检查文档完整性 | 验证文档目录和 README |
| `--naming` | 检查命名规范 | 全面检查文件命名 |
| `--all` | 执行所有检查 | 执行上述所有检查项（默认） |
| `-h, --help` | 显示帮助信息 | 打印使用说明 |

## 使用示例

### 1. 执行所有检查（默认）

```bash
# 不带参数，执行所有检查
./scripts/S2-Check.sh

# 或显式指定
./scripts/S2-Check.sh --all
```

输出示例：
```
检查构建状态...
✓ 构建目录结构完整

检查测试文件...
  测试文件数量: 20
✓ 所有测试文件命名符合规范 (T1-T20)

检查压测文件...
  压测文件数量: 6
✓ 所有压测文件命名符合规范 (B1-B6)

检查文档完整性...
  文档文件数量: 34
✓ 文档目录存在，包含 34 个文档

检查命名规范...
  检查测试文件命名...
  ✓ 测试文件命名规范
  检查压测文件命名...
  ✓ 压测文件命名规范
  检查示例文件命名...
  ✓ 示例文件命名规范
✓ 所有文件命名符合规范

========================================
✓ 所有检查通过
```

### 2. 单独检查构建状态

```bash
./scripts/S2-Check.sh --build
```

输出示例：
```
检查构建状态...
✓ 构建目录结构完整
```

### 3. 检查测试文件

```bash
./scripts/S2-Check.sh --tests
```

输出示例：
```
检查测试文件...
  测试文件数量: 20
✓ 所有测试文件命名符合规范 (T1-T20)
```

### 4. 检查命名规范

```bash
./scripts/S2-Check.sh --naming
```

输出示例（发现问题时）：
```
检查命名规范...
  检查测试文件命名...
  ✓ 测试文件命名规范
  检查压测文件命名...
✗ 压测文件命名不规范:
/path/to/benchmark/old_benchmark.cc
  检查示例文件命名...
  ✓ 示例文件命名规范
```

### 5. 检查文档完整性

```bash
./scripts/S2-Check.sh --docs
```

### 6. 检查压测文件

```bash
./scripts/S2-Check.sh --benchmarks
```

## 检查项详解

### 1. 构建状态检查 (--build)

**检查内容**：
- `build/` 目录是否存在
- `build/test/` 目录是否存在
- `build/example/` 目录是否存在
- `build/benchmark/` 目录是否存在

**通过条件**：所有必需目录都存在

**失败处理**：
```
✗ 构建目录不存在
✗ 缺少目录: test
✗ 缺少目录: example
```

### 2. 测试文件检查 (--tests)

**检查内容**：
- 统计 `test/` 目录下 `T*.cc` 文件数量
- 验证所有 `.cc` 文件是否符合 `T*-*.cc` 命名规范

**命名规范**：
- 格式：`T[数字]-[名称].cc`
- 示例：`T1-HttpParser.cc`、`T2-Chunk.cc`

**通过条件**：所有测试文件命名符合规范

**失败处理**：
```
⚠ 发现 2 个不符合命名规范的测试文件
/path/to/test/old_test.cc
/path/to/test/legacy_test.cc
```

### 3. 压测文件检查 (--benchmarks)

**检查内容**：
- 统计 `benchmark/` 目录下 `B*.cc` 文件数量
- 验证所有 `.cc` 文件是否符合 `B*-*.cc` 命名规范

**命名规范**：
- 格式：`B[数字]-[名称].cc`
- 示例：`B1-Chunked.cc`、`B2-FileTransfer.cc`

**通过条件**：所有压测文件命名符合规范

### 4. 文档完整性检查 (--docs)

**检查内容**：
- `docs/` 目录是否存在
- 统计 `docs/` 目录下 `.md` 文件数量
- `README.md` 是否存在于项目根目录

**通过条件**：
- 文档目录存在
- README.md 存在

**失败处理**：
```
✗ 缺少 README.md
```

### 5. 命名规范检查 (--naming)

**检查内容**：
- 测试文件：所有 `.cc` 文件必须符合 `T*-*.cc` 格式
- 压测文件：所有 `.cc` 文件必须符合 `B*-*.cc` 格式
- 示例文件：所有 `.cc` 文件必须符合 `E*-*.cc` 格式

**通过条件**：所有文件命名符合各自的规范

**失败处理**：列出所有不符合规范的文件路径

## 工作流程

### 检查流程图

```
开始
  ↓
解析命令行参数
  ↓
根据参数选择检查项
  ↓
执行各项检查
  ↓
收集检查结果
  ↓
生成统计报告
  ↓
返回退出码（0=成功，非0=失败）
```

### 目录结构要求

脚本依赖以下目录结构：

```
project_root/
├── scripts/
│   └── S2-Check.sh
├── build/              # 构建目录
│   ├── test/
│   ├── example/
│   └── benchmark/
├── test/               # 测试源码
│   ├── T1-HttpParser.cc
│   ├── T2-Chunk.cc
│   └── ...
├── benchmark/          # 压测源码
│   ├── B1-Chunked.cc
│   ├── B2-FileTransfer.cc
│   └── ...
├── example/            # 示例源码
│   ├── E1-EchoServer.cc
│   └── ...
├── docs/               # 文档目录
│   └── *.md
└── README.md           # 项目说明
```

## 命名规范说明

### 测试文件命名规范

**格式**：`T[序号]-[功能描述].cc`

**示例**：
- `T1-HttpParser.cc` - HTTP 解析器测试
- `T2-Chunk.cc` - Chunk 编码测试
- `T15-RangeEtagServer.cc` - Range 和 ETag 服务器测试

**规则**：
- 必须以 `T` 开头
- 序号从 1 开始递增
- 使用连字符 `-` 分隔序号和描述
- 描述使用 PascalCase 命名

### 压测文件命名规范

**格式**：`B[序号]-[功能描述].cc`

**示例**：
- `B1-Chunked.cc` - Chunked 编码压测
- `B2-FileTransfer.cc` - 文件传输压测
- `B3-HttpParser.cc` - HTTP 解析器压测

**规则**：
- 必须以 `B` 开头（Benchmark）
- 序号从 1 开始递增
- 使用连字符 `-` 分隔序号和描述
- 描述使用 PascalCase 命名

### 示例文件命名规范

**格式**：`E[序号]-[功能描述].cc`

**示例**：
- `E1-EchoServer.cc` - Echo 服务器示例
- `E2-HttpClient.cc` - HTTP 客户端示例

**规则**：
- 必须以 `E` 开头（Example）
- 序号从 1 开始递增
- 使用连字符 `-` 分隔序号和描述
- 描述使用 PascalCase 命名

## 错误处理

### 常见错误及解决方案

#### 1. 构建目录不存在

**错误信息**：
```
✗ 构建目录不存在
```

**解决方案**：
```bash
# 创建构建目录并编译
mkdir -p build
cd build
cmake ..
make
```

#### 2. 文件命名不规范

**错误信息**：
```
⚠ 发现 1 个不符合命名规范的测试文件
/path/to/test/old_test.cc
```

**解决方案**：
```bash
# 重命名文件以符合规范
mv test/old_test.cc test/T21-OldTest.cc

# 更新 CMakeLists.txt 中的文件引用
```

#### 3. 缺少 README

**错误信息**：
```
✗ 缺少 README.md
```

**解决方案**：
```bash
# 创建 README.md
touch README.md
# 编辑并添加项目说明
```

## 注意事项

### 使用建议

1. **提交代码前检查**：在提交代码前运行 `--all` 检查，确保符合规范
2. **CI/CD 集成**：将检查脚本集成到 CI/CD 流程中
3. **定期检查**：定期运行检查脚本，及时发现问题
4. **命名一致性**：严格遵守命名规范，保持代码库整洁

### 最佳实践

1. **开发流程**：
   ```bash
   # 1. 添加新文件
   touch test/T21-NewFeature.cc

   # 2. 编写代码

   # 3. 运行检查
   ./scripts/S2-Check.sh --naming

   # 4. 提交代码
   git add test/T21-NewFeature.cc
   git commit -m "feat: add new feature test"
   ```

2. **重构流程**：
   ```bash
   # 1. 重命名文件
   git mv test/old_test.cc test/T21-OldTest.cc

   # 2. 更新 CMakeLists.txt

   # 3. 运行检查
   ./scripts/S2-Check.sh --all

   # 4. 提交更改
   git commit -m "refactor: rename test file to follow naming convention"
   ```

3. **CI/CD 集成**：
   ```yaml
   # .github/workflows/check.yml
   - name: Check project structure
     run: |
       ./scripts/S2-Check.sh --all
       if [ $? -ne 0 ]; then
         echo "Project structure check failed"
         exit 1
       fi
   ```

## 脚本实现细节

### 关键函数

#### 1. `check_build()`
检查构建目录结构，验证 `build/test/`、`build/example/`、`build/benchmark/` 是否存在。

#### 2. `check_tests()`
统计测试文件数量，检查是否所有 `.cc` 文件都符合 `T*-*.cc` 命名规范。

#### 3. `check_benchmarks()`
统计压测文件数量，检查是否所有 `.cc` 文件都符合 `B*-*.cc` 命名规范。

#### 4. `check_docs()`
检查文档目录和 README.md 是否存在，统计文档数量。

#### 5. `check_naming()`
全面检查测试、压测、示例文件的命名规范，列出所有不符合规范的文件。

#### 6. `check_all()`
依次执行所有检查项，统计失败数量，生成总体报告。

### 颜色输出

脚本使用 ANSI 转义码实现彩色输出：

- **绿色**：检查通过（`\033[0;32m`）
- **红色**：检查失败（`\033[0;31m`）
- **黄色**：警告信息（`\033[1;33m`）
- **蓝色**：检查标题（`\033[0;34m`）

### 退出码

- **0**：所有检查通过
- **1**：至少一项检查失败

## 扩展功能

### 自定义检查规则

可以通过修改脚本添加自定义检查规则：

```bash
# 添加新的检查函数
check_custom() {
    echo -e "${BLUE}检查自定义规则...${NC}"
    # 自定义检查逻辑
    return 0
}

# 在 check_all 中调用
check_all() {
    local failed=0
    check_build || ((failed++))
    check_tests || ((failed++))
    check_custom || ((failed++))  # 添加自定义检查
    # ...
}
```

### 生成报告文件

可以将检查结果输出到文件：

```bash
# 生成检查报告
./scripts/S2-Check.sh --all > check_report.txt 2>&1
```

## 相关脚本

- **S1-Run.sh**：运行测试和示例的通用脚本
- **S3-BenchmarkStaticFiles.sh**：静态文件服务压测脚本
- **S4-TestRangeEtagManual.sh**：HTTP Range 和 ETag 手动测试脚本
- **S5-TestRangeEtagStress.sh**：HTTP Range 和 ETag 压力测试脚本

## 技术规格

| 项目 | 说明 |
|------|------|
| Shell 版本 | Bash 3.2+ |
| 依赖工具 | find, wc, grep |
| 支持平台 | Linux, macOS |
| 脚本位置 | `scripts/S2-Check.sh` |
| 配置文件 | 无 |

---

**文档版本**：v1.0
**创建日期**：2026-01-29
**维护团队**：galay-http 开发团队
